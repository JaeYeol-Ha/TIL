# ※ Algorithm Problem Solving

## DP (동적 계획법)

- DP = Dynamic Programming
- 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결
- 최종적으로 원래 주어진 입력의 문제를 해결
- 그리디 알고리즘 설계 기법과 같이 최적화 문제를 해결하는 알고리즘 기법

>  예시) 피보나치

## DP 의 구현 방식

### 1. Recursive (재귀적) 방식

- 내부에 시스템 호출 Stack을 사용하는 overhead가 발생할 수 있다.

### 2.  ★ Iterative (반복적) 방식

- Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현 한 것이 **성능면에서 보다 효율적**이다.

### 

## DFS(깊이 우선 탐색)

- 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선탐색을 하므로 

- **후입 선출 구조의 Stack**을 사용한다.

- 

- 

  





## Queue

- 선입 선출 구조 (FIFO)
- 서비스 대기 순번 등...
- 뒤에서 삽입, 앞에서 삭제
- Front 머리, Rear 꼬리 
- enQueue : 삽입 , deQueue : 삭제



enQueue

deQueue

isEmpty() - 공백인지

isFull() - 포화인가

peek() - 삭제없이 반환



선형 , 원형 queue : 배열

연결 queue : 리스트

→ 우선순위 큐  : 응용 형태



## BFS

- **Queue 활용**
- 너비 우선 탐색
- 시작점의 인접한 정점들을 모두 차례로 방문한 후 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문
- 